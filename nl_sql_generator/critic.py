"""LLM-powered SQL review helper.

The :class:`Critic` uses a GPT model to score and optionally fix generated SQL
statements. A JSONL log is produced for each review request.

Example:
    >>> c = Critic()
    >>> c.review("count users", "SELECT COUNT(*) FROM users", "- users(id)")
    {'fixed_sql': 'SELECT COUNT(*) FROM users', 'score': 0.9}
"""

from __future__ import annotations

__all__ = ["Critic"]

import json
import os
from datetime import datetime
from typing import Dict, List, Any

from .openai_responses import ResponsesClient


class Critic:
    """Review generated SQL using a GPT-4.1 critic persona."""

    def __init__(self, client: ResponsesClient | None = None, log_dir: str = "logs") -> None:
        """Create a critic instance.

        Args:
            client: Optional :class:`ResponsesClient` to use for completions.
            log_dir: Directory where reviews are logged.
        """

        self.client = client or ResponsesClient(model="gpt-4.1")
        self.log_dir = log_dir
        os.makedirs(self.log_dir, exist_ok=True)

    def _log(self, data: Dict[str, Any]) -> None:
        """Append ``data`` to the daily JSONL log file."""

        log_path = os.path.join(self.log_dir, f"critic-{datetime.utcnow():%Y%m%d}.jsonl")
        with open(log_path, "a", encoding="utf-8") as fh:
            fh.write(json.dumps(data, ensure_ascii=False) + "\n")

    def review(self, question: str, sql_candidate: str, schema_markdown: str) -> Dict[str, Any]:
        """Return critic assessment with optional fixes.

        Args:
            question: Original NL question.
            sql_candidate: SQL generated by the model.
            schema_markdown: Database schema in markdown form.

        Returns:
            Mapping containing ``fixed_sql`` and ``score`` between 0 and 1.
        """
        messages: List[Dict[str, str]] = [
            {
                "role": "system",
                "content": (
                    "Critic persona: Review SQL for correctness, index usage, security. "
                    "Respond with a JSON object: {'score': 0-1, 'reason': str, 'fixed_sql': str}."
                ),
            },
            {
                "role": "user",
                "content": (
                    f"Question: {question}\nSQL Candidate:\n{sql_candidate}\n\nSchema:\n{schema_markdown}"
                ),
            },
        ]

        response = self.client.run_jobs([messages])[0]
        try:
            result = json.loads(response)
        except json.JSONDecodeError:
            result = {"score": 0.0, "reason": "Invalid JSON", "fixed_sql": sql_candidate}

        self._log(
            {
                "question": question,
                "candidate_sql": sql_candidate,
                "schema": schema_markdown,
                "model_response": result,
            }
        )

        score = float(result.get("score", 0))
        fixed_sql = str(result.get("fixed_sql", sql_candidate))
        return {"fixed_sql": fixed_sql, "score": score}

    async def areview(
        self, question: str, sql_candidate: str, schema_markdown: str
    ) -> Dict[str, Any]:
        """Asynchronous version of :meth:`review`."""

        messages: List[Dict[str, str]] = [
            {
                "role": "system",
                "content": (
                    "Critic persona: Review SQL for correctness, index usage, security. "
                    "Respond with a JSON object: {'score': 0-1, 'reason': str, 'fixed_sql': str}."
                ),
            },
            {
                "role": "user",
                "content": (
                    f"Question: {question}\nSQL Candidate:\n{sql_candidate}\n\nSchema:\n{schema_markdown}"
                ),
            },
        ]

        response = (await self.client.arun_jobs([messages]))[0]
        try:
            result = json.loads(response)
        except json.JSONDecodeError:
            result = {"score": 0.0, "reason": "Invalid JSON", "fixed_sql": sql_candidate}

        self._log(
            {
                "question": question,
                "candidate_sql": sql_candidate,
                "schema": schema_markdown,
                "model_response": result,
            }
        )

        score = float(result.get("score", 0))
        fixed_sql = str(result.get("fixed_sql", sql_candidate))
        return {"fixed_sql": fixed_sql, "score": score}
